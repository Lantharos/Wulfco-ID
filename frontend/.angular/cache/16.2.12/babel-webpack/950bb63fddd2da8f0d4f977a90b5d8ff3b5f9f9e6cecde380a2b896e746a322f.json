{"ast":null,"code":"var Module = function () {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n  return function (Module) {\n    Module = Module || {};\n    var Module = typeof Module !== \"undefined\" ? Module : {};\n    var moduleOverrides = {};\n    var key;\n    for (key in Module) {\n      if (Module.hasOwnProperty(key)) {\n        moduleOverrides[key] = Module[key];\n      }\n    }\n    Module[\"arguments\"] = [];\n    Module[\"thisProgram\"] = \"./this.program\";\n    Module[\"quit\"] = function (status, toThrow) {\n      throw toThrow;\n    };\n    Module[\"preRun\"] = [];\n    Module[\"postRun\"] = [];\n    var ENVIRONMENT_IS_WEB = false;\n    var ENVIRONMENT_IS_WORKER = false;\n    var ENVIRONMENT_IS_NODE = false;\n    var ENVIRONMENT_IS_SHELL = false;\n    ENVIRONMENT_IS_WEB = typeof window === \"object\";\n    ENVIRONMENT_IS_WORKER = typeof importScripts === \"function\";\n    ENVIRONMENT_IS_NODE = typeof process === \"object\" && typeof require === \"function\" && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;\n    ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n    if (Module[\"ENVIRONMENT\"]) {\n      throw new Error(\"Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)\");\n    }\n    assert(typeof Module[\"memoryInitializerPrefixURL\"] === \"undefined\", \"Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead\");\n    assert(typeof Module[\"pthreadMainPrefixURL\"] === \"undefined\", \"Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead\");\n    assert(typeof Module[\"cdInitializerPrefixURL\"] === \"undefined\", \"Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead\");\n    assert(typeof Module[\"filePackagePrefixURL\"] === \"undefined\", \"Module.filePackagePrefixURL option was removed, use Module.locateFile instead\");\n    var scriptDirectory = \"\";\n    function locateFile(path) {\n      if (Module[\"locateFile\"]) {\n        return Module[\"locateFile\"](path, scriptDirectory);\n      } else {\n        return scriptDirectory + path;\n      }\n    }\n    if (ENVIRONMENT_IS_NODE) {\n      scriptDirectory = __dirname + \"/\";\n      var nodeFS;\n      var nodePath;\n      Module[\"read\"] = function shell_read(filename, binary) {\n        var ret;\n        if (!nodeFS) nodeFS = require(\"fs\");\n        if (!nodePath) nodePath = require(\"path\");\n        filename = nodePath[\"normalize\"](filename);\n        ret = nodeFS[\"readFileSync\"](filename);\n        return binary ? ret : ret.toString();\n      };\n      Module[\"readBinary\"] = function readBinary(filename) {\n        var ret = Module[\"read\"](filename, true);\n        if (!ret.buffer) {\n          ret = new Uint8Array(ret);\n        }\n        assert(ret.buffer);\n        return ret;\n      };\n      if (process[\"argv\"].length > 1) {\n        Module[\"thisProgram\"] = process[\"argv\"][1].replace(/\\\\/g, \"/\");\n      }\n      Module[\"arguments\"] = process[\"argv\"].slice(2);\n      process[\"on\"](\"uncaughtException\", function (ex) {\n        if (!(ex instanceof ExitStatus)) {\n          throw ex;\n        }\n      });\n      process[\"on\"](\"unhandledRejection\", function (reason, p) {\n        err(\"node.js exiting due to unhandled promise rejection\");\n        process[\"exit\"](1);\n      });\n      Module[\"quit\"] = function (status) {\n        process[\"exit\"](status);\n      };\n      Module[\"inspect\"] = function () {\n        return \"[Emscripten Module object]\";\n      };\n    } else if (ENVIRONMENT_IS_SHELL) {\n      if (typeof read != \"undefined\") {\n        Module[\"read\"] = function shell_read(f) {\n          return read(f);\n        };\n      }\n      Module[\"readBinary\"] = function readBinary(f) {\n        var data;\n        if (typeof readbuffer === \"function\") {\n          return new Uint8Array(readbuffer(f));\n        }\n        data = read(f, \"binary\");\n        assert(typeof data === \"object\");\n        return data;\n      };\n      if (typeof scriptArgs != \"undefined\") {\n        Module[\"arguments\"] = scriptArgs;\n      } else if (typeof arguments != \"undefined\") {\n        Module[\"arguments\"] = arguments;\n      }\n      if (typeof quit === \"function\") {\n        Module[\"quit\"] = function (status) {\n          quit(status);\n        };\n      }\n    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WEB) {\n        if (document.currentScript) {\n          scriptDirectory = document.currentScript.src;\n        }\n      } else {\n        scriptDirectory = self.location.href;\n      }\n      if (_scriptDir) {\n        scriptDirectory = _scriptDir;\n      }\n      if (scriptDirectory.indexOf(\"blob:\") !== 0) {\n        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf(\"/\") + 1);\n      } else {\n        scriptDirectory = \"\";\n      }\n      Module[\"read\"] = function shell_read(url) {\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", url, false);\n        xhr.send(null);\n        return xhr.responseText;\n      };\n      if (ENVIRONMENT_IS_WORKER) {\n        Module[\"readBinary\"] = function readBinary(url) {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"GET\", url, false);\n          xhr.responseType = \"arraybuffer\";\n          xhr.send(null);\n          return new Uint8Array(xhr.response);\n        };\n      }\n      Module[\"readAsync\"] = function readAsync(url, onload, onerror) {\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", url, true);\n        xhr.responseType = \"arraybuffer\";\n        xhr.onload = function xhr_onload() {\n          if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n            onload(xhr.response);\n            return;\n          }\n          onerror();\n        };\n        xhr.onerror = onerror;\n        xhr.send(null);\n      };\n      Module[\"setWindowTitle\"] = function (title) {\n        document.title = title;\n      };\n    } else {\n      throw new Error(\"environment detection error\");\n    }\n    var out = Module[\"print\"] || (typeof console !== \"undefined\" ? console.log.bind(console) : typeof print !== \"undefined\" ? print : null);\n    var err = Module[\"printErr\"] || (typeof printErr !== \"undefined\" ? printErr : typeof console !== \"undefined\" && console.warn.bind(console) || out);\n    for (key in moduleOverrides) {\n      if (moduleOverrides.hasOwnProperty(key)) {\n        Module[key] = moduleOverrides[key];\n      }\n    }\n    moduleOverrides = undefined;\n    var STACK_ALIGN = 16;\n    stackSave = stackRestore = stackAlloc = setTempRet0 = getTempRet0 = function () {\n      abort(\"cannot use the stack before compiled code is ready to run, and has provided stack access\");\n    };\n    function staticAlloc(size) {\n      assert(!staticSealed);\n      var ret = STATICTOP;\n      STATICTOP = STATICTOP + size + 15 & -16;\n      assert(STATICTOP < TOTAL_MEMORY, \"not enough memory for static allocation - increase TOTAL_MEMORY\");\n      return ret;\n    }\n    function dynamicAlloc(size) {\n      assert(DYNAMICTOP_PTR);\n      var ret = HEAP32[DYNAMICTOP_PTR >> 2];\n      var end = ret + size + 15 & -16;\n      HEAP32[DYNAMICTOP_PTR >> 2] = end;\n      if (end >= TOTAL_MEMORY) {\n        var success = enlargeMemory();\n        if (!success) {\n          HEAP32[DYNAMICTOP_PTR >> 2] = ret;\n          return 0;\n        }\n      }\n      return ret;\n    }\n    function alignMemory(size, factor) {\n      if (!factor) factor = STACK_ALIGN;\n      var ret = size = Math.ceil(size / factor) * factor;\n      return ret;\n    }\n    function getNativeTypeSize(type) {\n      switch (type) {\n        case \"i1\":\n        case \"i8\":\n          return 1;\n        case \"i16\":\n          return 2;\n        case \"i32\":\n          return 4;\n        case \"i64\":\n          return 8;\n        case \"float\":\n          return 4;\n        case \"double\":\n          return 8;\n        default:\n          {\n            if (type[type.length - 1] === \"*\") {\n              return 4;\n            } else if (type[0] === \"i\") {\n              var bits = parseInt(type.substr(1));\n              assert(bits % 8 === 0);\n              return bits / 8;\n            } else {\n              return 0;\n            }\n          }\n      }\n    }\n    function warnOnce(text) {\n      if (!warnOnce.shown) warnOnce.shown = {};\n      if (!warnOnce.shown[text]) {\n        warnOnce.shown[text] = 1;\n        err(text);\n      }\n    }\n    var asm2wasmImports = {\n      \"f64-rem\": function (x, y) {\n        return x % y;\n      },\n      \"debugger\": function () {\n        debugger;\n      }\n    };\n    var functionPointers = new Array(0);\n    var GLOBAL_BASE = 1024;\n    var ABORT = false;\n    var EXITSTATUS = 0;\n    function assert(condition, text) {\n      if (!condition) {\n        abort(\"Assertion failed: \" + text);\n      }\n    }\n    function setValue(ptr, value, type, noSafe) {\n      type = type || \"i8\";\n      if (type.charAt(type.length - 1) === \"*\") type = \"i32\";\n      switch (type) {\n        case \"i1\":\n          HEAP8[ptr >> 0] = value;\n          break;\n        case \"i8\":\n          HEAP8[ptr >> 0] = value;\n          break;\n        case \"i16\":\n          HEAP16[ptr >> 1] = value;\n          break;\n        case \"i32\":\n          HEAP32[ptr >> 2] = value;\n          break;\n        case \"i64\":\n          tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];\n          break;\n        case \"float\":\n          HEAPF32[ptr >> 2] = value;\n          break;\n        case \"double\":\n          HEAPF64[ptr >> 3] = value;\n          break;\n        default:\n          abort(\"invalid type for setValue: \" + type);\n      }\n    }\n    var ALLOC_NORMAL = 0;\n    var ALLOC_STATIC = 2;\n    var ALLOC_NONE = 4;\n    function allocate(slab, types, allocator, ptr) {\n      var zeroinit, size;\n      if (typeof slab === \"number\") {\n        zeroinit = true;\n        size = slab;\n      } else {\n        zeroinit = false;\n        size = slab.length;\n      }\n      var singleType = typeof types === \"string\" ? types : null;\n      var ret;\n      if (allocator == ALLOC_NONE) {\n        ret = ptr;\n      } else {\n        ret = [typeof _malloc === \"function\" ? _malloc : staticAlloc, stackAlloc, staticAlloc, dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));\n      }\n      if (zeroinit) {\n        var stop;\n        ptr = ret;\n        assert((ret & 3) == 0);\n        stop = ret + (size & ~3);\n        for (; ptr < stop; ptr += 4) {\n          HEAP32[ptr >> 2] = 0;\n        }\n        stop = ret + size;\n        while (ptr < stop) {\n          HEAP8[ptr++ >> 0] = 0;\n        }\n        return ret;\n      }\n      if (singleType === \"i8\") {\n        if (slab.subarray || slab.slice) {\n          HEAPU8.set(slab, ret);\n        } else {\n          HEAPU8.set(new Uint8Array(slab), ret);\n        }\n        return ret;\n      }\n      var i = 0,\n        type,\n        typeSize,\n        previousType;\n      while (i < size) {\n        var curr = slab[i];\n        type = singleType || types[i];\n        if (type === 0) {\n          i++;\n          continue;\n        }\n        assert(type, \"Must know what type to store in allocate!\");\n        if (type == \"i64\") type = \"i32\";\n        setValue(ret + i, curr, type);\n        if (previousType !== type) {\n          typeSize = getNativeTypeSize(type);\n          previousType = type;\n        }\n        i += typeSize;\n      }\n      return ret;\n    }\n    function Pointer_stringify(ptr, length) {\n      if (length === 0 || !ptr) return \"\";\n      var hasUtf = 0;\n      var t;\n      var i = 0;\n      while (1) {\n        assert(ptr + i < TOTAL_MEMORY);\n        t = HEAPU8[ptr + i >> 0];\n        hasUtf |= t;\n        if (t == 0 && !length) break;\n        i++;\n        if (length && i == length) break;\n      }\n      if (!length) length = i;\n      var ret = \"\";\n      if (hasUtf < 128) {\n        var MAX_CHUNK = 1024;\n        var curr;\n        while (length > 0) {\n          curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));\n          ret = ret ? ret + curr : curr;\n          ptr += MAX_CHUNK;\n          length -= MAX_CHUNK;\n        }\n        return ret;\n      }\n      return UTF8ToString(ptr);\n    }\n    var UTF8Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n    function UTF8ArrayToString(u8Array, idx) {\n      var endPtr = idx;\n      while (u8Array[endPtr]) ++endPtr;\n      if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\n        return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\n      } else {\n        var u0, u1, u2, u3, u4, u5;\n        var str = \"\";\n        while (1) {\n          u0 = u8Array[idx++];\n          if (!u0) return str;\n          if (!(u0 & 128)) {\n            str += String.fromCharCode(u0);\n            continue;\n          }\n          u1 = u8Array[idx++] & 63;\n          if ((u0 & 224) == 192) {\n            str += String.fromCharCode((u0 & 31) << 6 | u1);\n            continue;\n          }\n          u2 = u8Array[idx++] & 63;\n          if ((u0 & 240) == 224) {\n            u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n          } else {\n            u3 = u8Array[idx++] & 63;\n            if ((u0 & 248) == 240) {\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u3;\n            } else {\n              u4 = u8Array[idx++] & 63;\n              if ((u0 & 252) == 248) {\n                u0 = (u0 & 3) << 24 | u1 << 18 | u2 << 12 | u3 << 6 | u4;\n              } else {\n                u5 = u8Array[idx++] & 63;\n                u0 = (u0 & 1) << 30 | u1 << 24 | u2 << 18 | u3 << 12 | u4 << 6 | u5;\n              }\n            }\n          }\n          if (u0 < 65536) {\n            str += String.fromCharCode(u0);\n          } else {\n            var ch = u0 - 65536;\n            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n          }\n        }\n      }\n    }\n    function UTF8ToString(ptr) {\n      return UTF8ArrayToString(HEAPU8, ptr);\n    }\n    function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\n      if (!(maxBytesToWrite > 0)) return 0;\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1;\n      for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n        if (u >= 55296 && u <= 57343) {\n          var u1 = str.charCodeAt(++i);\n          u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n        }\n        if (u <= 127) {\n          if (outIdx >= endIdx) break;\n          outU8Array[outIdx++] = u;\n        } else if (u <= 2047) {\n          if (outIdx + 1 >= endIdx) break;\n          outU8Array[outIdx++] = 192 | u >> 6;\n          outU8Array[outIdx++] = 128 | u & 63;\n        } else if (u <= 65535) {\n          if (outIdx + 2 >= endIdx) break;\n          outU8Array[outIdx++] = 224 | u >> 12;\n          outU8Array[outIdx++] = 128 | u >> 6 & 63;\n          outU8Array[outIdx++] = 128 | u & 63;\n        } else if (u <= 2097151) {\n          if (outIdx + 3 >= endIdx) break;\n          outU8Array[outIdx++] = 240 | u >> 18;\n          outU8Array[outIdx++] = 128 | u >> 12 & 63;\n          outU8Array[outIdx++] = 128 | u >> 6 & 63;\n          outU8Array[outIdx++] = 128 | u & 63;\n        } else if (u <= 67108863) {\n          if (outIdx + 4 >= endIdx) break;\n          outU8Array[outIdx++] = 248 | u >> 24;\n          outU8Array[outIdx++] = 128 | u >> 18 & 63;\n          outU8Array[outIdx++] = 128 | u >> 12 & 63;\n          outU8Array[outIdx++] = 128 | u >> 6 & 63;\n          outU8Array[outIdx++] = 128 | u & 63;\n        } else {\n          if (outIdx + 5 >= endIdx) break;\n          outU8Array[outIdx++] = 252 | u >> 30;\n          outU8Array[outIdx++] = 128 | u >> 24 & 63;\n          outU8Array[outIdx++] = 128 | u >> 18 & 63;\n          outU8Array[outIdx++] = 128 | u >> 12 & 63;\n          outU8Array[outIdx++] = 128 | u >> 6 & 63;\n          outU8Array[outIdx++] = 128 | u & 63;\n        }\n      }\n      outU8Array[outIdx] = 0;\n      return outIdx - startIdx;\n    }\n    function lengthBytesUTF8(str) {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n        if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;\n        if (u <= 127) {\n          ++len;\n        } else if (u <= 2047) {\n          len += 2;\n        } else if (u <= 65535) {\n          len += 3;\n        } else if (u <= 2097151) {\n          len += 4;\n        } else if (u <= 67108863) {\n          len += 5;\n        } else {\n          len += 6;\n        }\n      }\n      return len;\n    }\n    var UTF16Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-16le\") : undefined;\n    function demangle(func) {\n      warnOnce(\"warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling\");\n      return func;\n    }\n    function demangleAll(text) {\n      var regex = /__Z[\\w\\d_]+/g;\n      return text.replace(regex, function (x) {\n        var y = demangle(x);\n        return x === y ? x : x + \" [\" + y + \"]\";\n      });\n    }\n    function jsStackTrace() {\n      var err = new Error();\n      if (!err.stack) {\n        try {\n          throw new Error(0);\n        } catch (e) {\n          err = e;\n        }\n        if (!err.stack) {\n          return \"(no stack trace available)\";\n        }\n      }\n      return err.stack.toString();\n    }\n    function stackTrace() {\n      var js = jsStackTrace();\n      if (Module[\"extraStackTrace\"]) js += \"\\n\" + Module[\"extraStackTrace\"]();\n      return demangleAll(js);\n    }\n    var WASM_PAGE_SIZE = 65536;\n    var ASMJS_PAGE_SIZE = 16777216;\n    function alignUp(x, multiple) {\n      if (x % multiple > 0) {\n        x += multiple - x % multiple;\n      }\n      return x;\n    }\n    var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n    function updateGlobalBuffer(buf) {\n      Module[\"buffer\"] = buffer = buf;\n    }\n    function updateGlobalBufferViews() {\n      Module[\"HEAP8\"] = HEAP8 = new Int8Array(buffer);\n      Module[\"HEAP16\"] = HEAP16 = new Int16Array(buffer);\n      Module[\"HEAP32\"] = HEAP32 = new Int32Array(buffer);\n      Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(buffer);\n      Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(buffer);\n      Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(buffer);\n      Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(buffer);\n      Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(buffer);\n    }\n    var STATIC_BASE, STATICTOP, staticSealed;\n    var STACK_BASE, STACKTOP, STACK_MAX;\n    var DYNAMIC_BASE, DYNAMICTOP_PTR;\n    STATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0;\n    staticSealed = false;\n    function writeStackCookie() {\n      assert((STACK_MAX & 3) == 0);\n      HEAPU32[(STACK_MAX >> 2) - 1] = 34821223;\n      HEAPU32[(STACK_MAX >> 2) - 2] = 2310721022;\n    }\n    function checkStackCookie() {\n      if (HEAPU32[(STACK_MAX >> 2) - 1] != 34821223 || HEAPU32[(STACK_MAX >> 2) - 2] != 2310721022) {\n        abort(\"Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x\" + HEAPU32[(STACK_MAX >> 2) - 2].toString(16) + \" \" + HEAPU32[(STACK_MAX >> 2) - 1].toString(16));\n      }\n      if (HEAP32[0] !== 1668509029) throw \"Runtime error: The application has corrupted its heap memory area (address zero)!\";\n    }\n    function abortStackOverflow(allocSize) {\n      abort(\"Stack overflow! Attempted to allocate \" + allocSize + \" bytes on the stack, but stack has only \" + (STACK_MAX - stackSave() + allocSize) + \" bytes available!\");\n    }\n    function abortOnCannotGrowMemory() {\n      abort(\"Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value \" + TOTAL_MEMORY + \", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 \");\n    }\n    function enlargeMemory() {\n      abortOnCannotGrowMemory();\n    }\n    var TOTAL_STACK = Module[\"TOTAL_STACK\"] || 5242880;\n    var TOTAL_MEMORY = Module[\"TOTAL_MEMORY\"] || 545259520;\n    if (TOTAL_MEMORY < TOTAL_STACK) err(\"TOTAL_MEMORY should be larger than TOTAL_STACK, was \" + TOTAL_MEMORY + \"! (TOTAL_STACK=\" + TOTAL_STACK + \")\");\n    assert(typeof Int32Array !== \"undefined\" && typeof Float64Array !== \"undefined\" && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined, \"JS engine does not provide full typed array support\");\n    if (Module[\"buffer\"]) {\n      buffer = Module[\"buffer\"];\n      assert(buffer.byteLength === TOTAL_MEMORY, \"provided buffer should be \" + TOTAL_MEMORY + \" bytes, but it is \" + buffer.byteLength);\n    } else {\n      if (typeof WebAssembly === \"object\" && typeof WebAssembly.Memory === \"function\") {\n        assert(TOTAL_MEMORY % WASM_PAGE_SIZE === 0);\n        Module[\"wasmMemory\"] = new WebAssembly.Memory({\n          \"initial\": TOTAL_MEMORY / WASM_PAGE_SIZE,\n          \"maximum\": TOTAL_MEMORY / WASM_PAGE_SIZE\n        });\n        buffer = Module[\"wasmMemory\"].buffer;\n      } else {\n        buffer = new ArrayBuffer(TOTAL_MEMORY);\n      }\n      assert(buffer.byteLength === TOTAL_MEMORY);\n      Module[\"buffer\"] = buffer;\n    }\n    updateGlobalBufferViews();\n    function getTotalMemory() {\n      return TOTAL_MEMORY;\n    }\n    HEAP32[0] = 1668509029;\n    HEAP16[1] = 25459;\n    if (HEAPU8[2] !== 115 || HEAPU8[3] !== 99) throw \"Runtime error: expected the system to be little-endian!\";\n    function callRuntimeCallbacks(callbacks) {\n      while (callbacks.length > 0) {\n        var callback = callbacks.shift();\n        if (typeof callback == \"function\") {\n          callback();\n          continue;\n        }\n        var func = callback.func;\n        if (typeof func === \"number\") {\n          if (callback.arg === undefined) {\n            Module[\"dynCall_v\"](func);\n          } else {\n            Module[\"dynCall_vi\"](func, callback.arg);\n          }\n        } else {\n          func(callback.arg === undefined ? null : callback.arg);\n        }\n      }\n    }\n    var __ATPRERUN__ = [];\n    var __ATINIT__ = [];\n    var __ATMAIN__ = [];\n    var __ATPOSTRUN__ = [];\n    var runtimeInitialized = false;\n    var runtimeExited = false;\n    function preRun() {\n      if (Module[\"preRun\"]) {\n        if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [Module[\"preRun\"]];\n        while (Module[\"preRun\"].length) {\n          addOnPreRun(Module[\"preRun\"].shift());\n        }\n      }\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n    function ensureInitRuntime() {\n      checkStackCookie();\n      if (runtimeInitialized) return;\n      runtimeInitialized = true;\n      callRuntimeCallbacks(__ATINIT__);\n    }\n    function preMain() {\n      checkStackCookie();\n      callRuntimeCallbacks(__ATMAIN__);\n    }\n    function postRun() {\n      checkStackCookie();\n      if (Module[\"postRun\"]) {\n        if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [Module[\"postRun\"]];\n        while (Module[\"postRun\"].length) {\n          addOnPostRun(Module[\"postRun\"].shift());\n        }\n      }\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n    assert(Math[\"imul\"] && Math[\"fround\"] && Math[\"clz32\"] && Math[\"trunc\"], \"this is a legacy browser, build with LEGACY_VM_SUPPORT\");\n    var Math_abs = Math.abs;\n    var Math_ceil = Math.ceil;\n    var Math_floor = Math.floor;\n    var Math_min = Math.min;\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null;\n    var runDependencyTracking = {};\n    function addRunDependency(id) {\n      runDependencies++;\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n      if (id) {\n        assert(!runDependencyTracking[id]);\n        runDependencyTracking[id] = 1;\n        if (runDependencyWatcher === null && typeof setInterval !== \"undefined\") {\n          runDependencyWatcher = setInterval(function () {\n            if (ABORT) {\n              clearInterval(runDependencyWatcher);\n              runDependencyWatcher = null;\n              return;\n            }\n            var shown = false;\n            for (var dep in runDependencyTracking) {\n              if (!shown) {\n                shown = true;\n                err(\"still waiting on run dependencies:\");\n              }\n              err(\"dependency: \" + dep);\n            }\n            if (shown) {\n              err(\"(end of list)\");\n            }\n          }, 1e4);\n        }\n      } else {\n        err(\"warning: run dependency added without ID\");\n      }\n    }\n    function removeRunDependency(id) {\n      runDependencies--;\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n      if (id) {\n        assert(runDependencyTracking[id]);\n        delete runDependencyTracking[id];\n      } else {\n        err(\"warning: run dependency removed without ID\");\n      }\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback();\n        }\n      }\n    }\n    Module[\"preloadedImages\"] = {};\n    Module[\"preloadedAudios\"] = {};\n    var FS = {\n      error: function () {\n        abort(\"Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1\");\n      },\n      init: function () {\n        FS.error();\n      },\n      createDataFile: function () {\n        FS.error();\n      },\n      createPreloadedFile: function () {\n        FS.error();\n      },\n      createLazyFile: function () {\n        FS.error();\n      },\n      open: function () {\n        FS.error();\n      },\n      mkdev: function () {\n        FS.error();\n      },\n      registerDevice: function () {\n        FS.error();\n      },\n      analyzePath: function () {\n        FS.error();\n      },\n      loadFilesFromDB: function () {\n        FS.error();\n      },\n      ErrnoError: function ErrnoError() {\n        FS.error();\n      }\n    };\n    Module[\"FS_createDataFile\"] = FS.createDataFile;\n    Module[\"FS_createPreloadedFile\"] = FS.createPreloadedFile;\n    var dataURIPrefix = \"data:application/octet-stream;base64,\";\n    function isDataURI(filename) {\n      return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;\n    }\n    function integrateWasmJS() {\n      var wasmTextFile = \"argon2.wast\";\n      var wasmBinaryFile = \"argon2.wasm\";\n      var asmjsCodeFile = \"argon2.temp.asm.js\";\n      if (!isDataURI(wasmTextFile)) {\n        wasmTextFile = locateFile(wasmTextFile);\n      }\n      if (!isDataURI(wasmBinaryFile)) {\n        wasmBinaryFile = locateFile(wasmBinaryFile);\n      }\n      if (!isDataURI(asmjsCodeFile)) {\n        asmjsCodeFile = locateFile(asmjsCodeFile);\n      }\n      var wasmPageSize = 64 * 1024;\n      var info = {\n        \"global\": null,\n        \"env\": null,\n        \"asm2wasm\": asm2wasmImports,\n        \"parent\": Module\n      };\n      var exports = null;\n      function mergeMemory(newBuffer) {\n        var oldBuffer = Module[\"buffer\"];\n        if (newBuffer.byteLength < oldBuffer.byteLength) {\n          err(\"the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here\");\n        }\n        var oldView = new Int8Array(oldBuffer);\n        var newView = new Int8Array(newBuffer);\n        newView.set(oldView);\n        updateGlobalBuffer(newBuffer);\n        updateGlobalBufferViews();\n      }\n      function fixImports(imports) {\n        return imports;\n      }\n      function getBinary() {\n        try {\n          if (Module[\"wasmBinary\"]) {\n            return new Uint8Array(Module[\"wasmBinary\"]);\n          }\n          if (Module[\"readBinary\"]) {\n            return Module[\"readBinary\"](wasmBinaryFile);\n          } else {\n            throw \"both async and sync fetching of the wasm failed\";\n          }\n        } catch (err) {\n          abort(err);\n        }\n      }\n      function getBinaryPromise() {\n        if (!Module[\"wasmBinary\"] && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === \"function\") {\n          return fetch(wasmBinaryFile, {\n            credentials: \"same-origin\"\n          }).then(function (response) {\n            if (!response[\"ok\"]) {\n              throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n            }\n            return response[\"arrayBuffer\"]();\n          }).catch(function () {\n            return getBinary();\n          });\n        }\n        return new Promise(function (resolve, reject) {\n          resolve(getBinary());\n        });\n      }\n      function doNativeWasm(global, env, providedBuffer) {\n        if (typeof WebAssembly !== \"object\") {\n          abort(\"No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.\");\n          err(\"no native wasm support detected\");\n          return false;\n        }\n        if (!(Module[\"wasmMemory\"] instanceof WebAssembly.Memory)) {\n          err(\"no native wasm Memory in use\");\n          return false;\n        }\n        env[\"memory\"] = Module[\"wasmMemory\"];\n        info[\"global\"] = {\n          \"NaN\": NaN,\n          \"Infinity\": Infinity\n        };\n        info[\"global.Math\"] = Math;\n        info[\"env\"] = env;\n        function receiveInstance(instance, module) {\n          exports = instance.exports;\n          if (exports.memory) mergeMemory(exports.memory);\n          Module[\"asm\"] = exports;\n          Module[\"usingWasm\"] = true;\n          removeRunDependency(\"wasm-instantiate\");\n        }\n        addRunDependency(\"wasm-instantiate\");\n        if (Module[\"instantiateWasm\"]) {\n          try {\n            return Module[\"instantiateWasm\"](info, receiveInstance);\n          } catch (e) {\n            err(\"Module.instantiateWasm callback failed with error: \" + e);\n            return false;\n          }\n        }\n        var trueModule = Module;\n        function receiveInstantiatedSource(output) {\n          assert(Module === trueModule, \"the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?\");\n          trueModule = null;\n          receiveInstance(output[\"instance\"], output[\"module\"]);\n        }\n        function instantiateArrayBuffer(receiver) {\n          getBinaryPromise().then(function (binary) {\n            return WebAssembly.instantiate(binary, info);\n          }).then(receiver).catch(function (reason) {\n            err(\"failed to asynchronously prepare wasm: \" + reason);\n            abort(reason);\n          });\n        }\n        if (!Module[\"wasmBinary\"] && typeof WebAssembly.instantiateStreaming === \"function\" && !isDataURI(wasmBinaryFile) && typeof fetch === \"function\") {\n          WebAssembly.instantiateStreaming(fetch(wasmBinaryFile, {\n            credentials: \"same-origin\"\n          }), info).then(receiveInstantiatedSource).catch(function (reason) {\n            err(\"wasm streaming compile failed: \" + reason);\n            err(\"falling back to ArrayBuffer instantiation\");\n            instantiateArrayBuffer(receiveInstantiatedSource);\n          });\n        } else {\n          instantiateArrayBuffer(receiveInstantiatedSource);\n        }\n        return {};\n      }\n      Module[\"asmPreload\"] = Module[\"asm\"];\n      var asmjsReallocBuffer = Module[\"reallocBuffer\"];\n      var wasmReallocBuffer = function (size) {\n        var PAGE_MULTIPLE = Module[\"usingWasm\"] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE;\n        size = alignUp(size, PAGE_MULTIPLE);\n        var old = Module[\"buffer\"];\n        var oldSize = old.byteLength;\n        if (Module[\"usingWasm\"]) {\n          try {\n            var result = Module[\"wasmMemory\"].grow((size - oldSize) / wasmPageSize);\n            if (result !== (-1 | 0)) {\n              return Module[\"buffer\"] = Module[\"wasmMemory\"].buffer;\n            } else {\n              return null;\n            }\n          } catch (e) {\n            console.error(\"Module.reallocBuffer: Attempted to grow from \" + oldSize + \" bytes to \" + size + \" bytes, but got error: \" + e);\n            return null;\n          }\n        }\n      };\n      Module[\"reallocBuffer\"] = function (size) {\n        if (finalMethod === \"asmjs\") {\n          return asmjsReallocBuffer(size);\n        } else {\n          return wasmReallocBuffer(size);\n        }\n      };\n      var finalMethod = \"\";\n      Module[\"asm\"] = function (global, env, providedBuffer) {\n        env = fixImports(env);\n        if (!env[\"table\"]) {\n          var TABLE_SIZE = Module[\"wasmTableSize\"];\n          if (TABLE_SIZE === undefined) TABLE_SIZE = 1024;\n          var MAX_TABLE_SIZE = Module[\"wasmMaxTableSize\"];\n          if (typeof WebAssembly === \"object\" && typeof WebAssembly.Table === \"function\") {\n            if (MAX_TABLE_SIZE !== undefined) {\n              env[\"table\"] = new WebAssembly.Table({\n                \"initial\": TABLE_SIZE,\n                \"maximum\": MAX_TABLE_SIZE,\n                \"element\": \"anyfunc\"\n              });\n            } else {\n              env[\"table\"] = new WebAssembly.Table({\n                \"initial\": TABLE_SIZE,\n                element: \"anyfunc\"\n              });\n            }\n          } else {\n            env[\"table\"] = new Array(TABLE_SIZE);\n          }\n          Module[\"wasmTable\"] = env[\"table\"];\n        }\n        if (!env[\"memoryBase\"]) {\n          env[\"memoryBase\"] = Module[\"STATIC_BASE\"];\n        }\n        if (!env[\"tableBase\"]) {\n          env[\"tableBase\"] = 0;\n        }\n        var exports;\n        exports = doNativeWasm(global, env, providedBuffer);\n        assert(exports, \"no binaryen method succeeded. consider enabling more options, like interpreting, if you want that: http://kripken.github.io/emscripten-site/docs/compiling/WebAssembly.html#binaryen-methods\");\n        return exports;\n      };\n    }\n    integrateWasmJS();\n    STATIC_BASE = GLOBAL_BASE;\n    STATICTOP = STATIC_BASE + 3424;\n    __ATINIT__.push();\n    var STATIC_BUMP = 3424;\n    Module[\"STATIC_BASE\"] = STATIC_BASE;\n    Module[\"STATIC_BUMP\"] = STATIC_BUMP;\n    var tempDoublePtr = STATICTOP;\n    STATICTOP += 16;\n    assert(tempDoublePtr % 8 == 0);\n    function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.set(HEAPU8.subarray(src, src + num), dest);\n      return dest;\n    }\n    function _pthread_join() {}\n    function ___setErrNo(value) {\n      if (Module[\"___errno_location\"]) HEAP32[Module[\"___errno_location\"]() >> 2] = value;else err(\"failed to set errno from JS\");\n      return value;\n    }\n    DYNAMICTOP_PTR = staticAlloc(4);\n    STACK_BASE = STACKTOP = alignMemory(STATICTOP);\n    STACK_MAX = STACK_BASE + TOTAL_STACK;\n    DYNAMIC_BASE = alignMemory(STACK_MAX);\n    HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;\n    staticSealed = true;\n    assert(DYNAMIC_BASE < TOTAL_MEMORY, \"TOTAL_MEMORY not big enough for stack\");\n    function intArrayFromString(stringy, dontAddNull, length) {\n      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n      var u8array = new Array(len);\n      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n      if (dontAddNull) u8array.length = numBytesWritten;\n      return u8array;\n    }\n    Module[\"wasmTableSize\"] = 0;\n    Module[\"wasmMaxTableSize\"] = 0;\n    Module.asmGlobalArg = {};\n    Module.asmLibraryArg = {\n      \"enlargeMemory\": enlargeMemory,\n      \"getTotalMemory\": getTotalMemory,\n      \"abortOnCannotGrowMemory\": abortOnCannotGrowMemory,\n      \"abortStackOverflow\": abortStackOverflow,\n      \"___setErrNo\": ___setErrNo,\n      \"_emscripten_memcpy_big\": _emscripten_memcpy_big,\n      \"_pthread_join\": _pthread_join,\n      \"DYNAMICTOP_PTR\": DYNAMICTOP_PTR,\n      \"STACKTOP\": STACKTOP,\n      \"STACK_MAX\": STACK_MAX\n    };\n    var asm = Module[\"asm\"](Module.asmGlobalArg, Module.asmLibraryArg, buffer);\n    var real__argon2_error_message = asm[\"_argon2_error_message\"];\n    asm[\"_argon2_error_message\"] = function () {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return real__argon2_error_message.apply(null, arguments);\n    };\n    var real__argon2_hash = asm[\"_argon2_hash\"];\n    asm[\"_argon2_hash\"] = function () {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return real__argon2_hash.apply(null, arguments);\n    };\n    var real__free = asm[\"_free\"];\n    asm[\"_free\"] = function () {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return real__free.apply(null, arguments);\n    };\n    var real__malloc = asm[\"_malloc\"];\n    asm[\"_malloc\"] = function () {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return real__malloc.apply(null, arguments);\n    };\n    var real__sbrk = asm[\"_sbrk\"];\n    asm[\"_sbrk\"] = function () {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return real__sbrk.apply(null, arguments);\n    };\n    var real_establishStackSpace = asm[\"establishStackSpace\"];\n    asm[\"establishStackSpace\"] = function () {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return real_establishStackSpace.apply(null, arguments);\n    };\n    var real_getTempRet0 = asm[\"getTempRet0\"];\n    asm[\"getTempRet0\"] = function () {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return real_getTempRet0.apply(null, arguments);\n    };\n    var real_setTempRet0 = asm[\"setTempRet0\"];\n    asm[\"setTempRet0\"] = function () {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return real_setTempRet0.apply(null, arguments);\n    };\n    var real_setThrew = asm[\"setThrew\"];\n    asm[\"setThrew\"] = function () {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return real_setThrew.apply(null, arguments);\n    };\n    var real_stackAlloc = asm[\"stackAlloc\"];\n    asm[\"stackAlloc\"] = function () {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return real_stackAlloc.apply(null, arguments);\n    };\n    var real_stackRestore = asm[\"stackRestore\"];\n    asm[\"stackRestore\"] = function () {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return real_stackRestore.apply(null, arguments);\n    };\n    var real_stackSave = asm[\"stackSave\"];\n    asm[\"stackSave\"] = function () {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return real_stackSave.apply(null, arguments);\n    };\n    Module[\"asm\"] = asm;\n    var _argon2_error_message = Module[\"_argon2_error_message\"] = function () {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"_argon2_error_message\"].apply(null, arguments);\n    };\n    var _argon2_hash = Module[\"_argon2_hash\"] = function () {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"_argon2_hash\"].apply(null, arguments);\n    };\n    var _free = Module[\"_free\"] = function () {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"_free\"].apply(null, arguments);\n    };\n    var _malloc = Module[\"_malloc\"] = function () {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"_malloc\"].apply(null, arguments);\n    };\n    var _sbrk = Module[\"_sbrk\"] = function () {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"_sbrk\"].apply(null, arguments);\n    };\n    var establishStackSpace = Module[\"establishStackSpace\"] = function () {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"establishStackSpace\"].apply(null, arguments);\n    };\n    var getTempRet0 = Module[\"getTempRet0\"] = function () {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"getTempRet0\"].apply(null, arguments);\n    };\n    var setTempRet0 = Module[\"setTempRet0\"] = function () {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"setTempRet0\"].apply(null, arguments);\n    };\n    var setThrew = Module[\"setThrew\"] = function () {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"setThrew\"].apply(null, arguments);\n    };\n    var stackAlloc = Module[\"stackAlloc\"] = function () {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"stackAlloc\"].apply(null, arguments);\n    };\n    var stackRestore = Module[\"stackRestore\"] = function () {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"stackRestore\"].apply(null, arguments);\n    };\n    var stackSave = Module[\"stackSave\"] = function () {\n      assert(runtimeInitialized, \"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");\n      assert(!runtimeExited, \"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n      return Module[\"asm\"][\"stackSave\"].apply(null, arguments);\n    };\n    Module[\"asm\"] = asm;\n    Module[\"intArrayFromString\"] = intArrayFromString;\n    if (!Module[\"intArrayToString\"]) Module[\"intArrayToString\"] = function () {\n      abort(\"'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"ccall\"]) Module[\"ccall\"] = function () {\n      abort(\"'ccall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"cwrap\"]) Module[\"cwrap\"] = function () {\n      abort(\"'cwrap' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"setValue\"]) Module[\"setValue\"] = function () {\n      abort(\"'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getValue\"]) Module[\"getValue\"] = function () {\n      abort(\"'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    Module[\"allocate\"] = allocate;\n    if (!Module[\"getMemory\"]) Module[\"getMemory\"] = function () {\n      abort(\"'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    Module[\"Pointer_stringify\"] = Pointer_stringify;\n    if (!Module[\"AsciiToString\"]) Module[\"AsciiToString\"] = function () {\n      abort(\"'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stringToAscii\"]) Module[\"stringToAscii\"] = function () {\n      abort(\"'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"UTF8ArrayToString\"]) Module[\"UTF8ArrayToString\"] = function () {\n      abort(\"'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"UTF8ToString\"]) Module[\"UTF8ToString\"] = function () {\n      abort(\"'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stringToUTF8Array\"]) Module[\"stringToUTF8Array\"] = function () {\n      abort(\"'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stringToUTF8\"]) Module[\"stringToUTF8\"] = function () {\n      abort(\"'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"lengthBytesUTF8\"]) Module[\"lengthBytesUTF8\"] = function () {\n      abort(\"'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"UTF16ToString\"]) Module[\"UTF16ToString\"] = function () {\n      abort(\"'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stringToUTF16\"]) Module[\"stringToUTF16\"] = function () {\n      abort(\"'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"lengthBytesUTF16\"]) Module[\"lengthBytesUTF16\"] = function () {\n      abort(\"'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"UTF32ToString\"]) Module[\"UTF32ToString\"] = function () {\n      abort(\"'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stringToUTF32\"]) Module[\"stringToUTF32\"] = function () {\n      abort(\"'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"lengthBytesUTF32\"]) Module[\"lengthBytesUTF32\"] = function () {\n      abort(\"'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"allocateUTF8\"]) Module[\"allocateUTF8\"] = function () {\n      abort(\"'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stackTrace\"]) Module[\"stackTrace\"] = function () {\n      abort(\"'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addOnPreRun\"]) Module[\"addOnPreRun\"] = function () {\n      abort(\"'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addOnInit\"]) Module[\"addOnInit\"] = function () {\n      abort(\"'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addOnPreMain\"]) Module[\"addOnPreMain\"] = function () {\n      abort(\"'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addOnExit\"]) Module[\"addOnExit\"] = function () {\n      abort(\"'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addOnPostRun\"]) Module[\"addOnPostRun\"] = function () {\n      abort(\"'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"writeStringToMemory\"]) Module[\"writeStringToMemory\"] = function () {\n      abort(\"'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"writeArrayToMemory\"]) Module[\"writeArrayToMemory\"] = function () {\n      abort(\"'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"writeAsciiToMemory\"]) Module[\"writeAsciiToMemory\"] = function () {\n      abort(\"'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addRunDependency\"]) Module[\"addRunDependency\"] = function () {\n      abort(\"'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"removeRunDependency\"]) Module[\"removeRunDependency\"] = function () {\n      abort(\"'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"ENV\"]) Module[\"ENV\"] = function () {\n      abort(\"'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"FS\"]) Module[\"FS\"] = function () {\n      abort(\"'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"FS_createFolder\"]) Module[\"FS_createFolder\"] = function () {\n      abort(\"'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_createPath\"]) Module[\"FS_createPath\"] = function () {\n      abort(\"'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_createDataFile\"]) Module[\"FS_createDataFile\"] = function () {\n      abort(\"'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_createPreloadedFile\"]) Module[\"FS_createPreloadedFile\"] = function () {\n      abort(\"'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_createLazyFile\"]) Module[\"FS_createLazyFile\"] = function () {\n      abort(\"'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_createLink\"]) Module[\"FS_createLink\"] = function () {\n      abort(\"'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_createDevice\"]) Module[\"FS_createDevice\"] = function () {\n      abort(\"'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_unlink\"]) Module[\"FS_unlink\"] = function () {\n      abort(\"'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"GL\"]) Module[\"GL\"] = function () {\n      abort(\"'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"staticAlloc\"]) Module[\"staticAlloc\"] = function () {\n      abort(\"'staticAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"dynamicAlloc\"]) Module[\"dynamicAlloc\"] = function () {\n      abort(\"'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"warnOnce\"]) Module[\"warnOnce\"] = function () {\n      abort(\"'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"loadDynamicLibrary\"]) Module[\"loadDynamicLibrary\"] = function () {\n      abort(\"'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"loadWebAssemblyModule\"]) Module[\"loadWebAssemblyModule\"] = function () {\n      abort(\"'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getLEB\"]) Module[\"getLEB\"] = function () {\n      abort(\"'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getFunctionTables\"]) Module[\"getFunctionTables\"] = function () {\n      abort(\"'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"alignFunctionTables\"]) Module[\"alignFunctionTables\"] = function () {\n      abort(\"'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"registerFunctions\"]) Module[\"registerFunctions\"] = function () {\n      abort(\"'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addFunction\"]) Module[\"addFunction\"] = function () {\n      abort(\"'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"removeFunction\"]) Module[\"removeFunction\"] = function () {\n      abort(\"'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getFuncWrapper\"]) Module[\"getFuncWrapper\"] = function () {\n      abort(\"'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"prettyPrint\"]) Module[\"prettyPrint\"] = function () {\n      abort(\"'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"makeBigInt\"]) Module[\"makeBigInt\"] = function () {\n      abort(\"'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"dynCall\"]) Module[\"dynCall\"] = function () {\n      abort(\"'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getCompilerSetting\"]) Module[\"getCompilerSetting\"] = function () {\n      abort(\"'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stackSave\"]) Module[\"stackSave\"] = function () {\n      abort(\"'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stackRestore\"]) Module[\"stackRestore\"] = function () {\n      abort(\"'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stackAlloc\"]) Module[\"stackAlloc\"] = function () {\n      abort(\"'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"establishStackSpace\"]) Module[\"establishStackSpace\"] = function () {\n      abort(\"'establishStackSpace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"print\"]) Module[\"print\"] = function () {\n      abort(\"'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"printErr\"]) Module[\"printErr\"] = function () {\n      abort(\"'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    Module[\"ALLOC_NORMAL\"] = ALLOC_NORMAL;\n    if (!Module[\"ALLOC_STACK\"]) Object.defineProperty(Module, \"ALLOC_STACK\", {\n      get: function () {\n        abort(\"'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    });\n    if (!Module[\"ALLOC_STATIC\"]) Object.defineProperty(Module, \"ALLOC_STATIC\", {\n      get: function () {\n        abort(\"'ALLOC_STATIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    });\n    if (!Module[\"ALLOC_DYNAMIC\"]) Object.defineProperty(Module, \"ALLOC_DYNAMIC\", {\n      get: function () {\n        abort(\"'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    });\n    if (!Module[\"ALLOC_NONE\"]) Object.defineProperty(Module, \"ALLOC_NONE\", {\n      get: function () {\n        abort(\"'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    });\n    Module[\"then\"] = function (func) {\n      if (Module[\"calledRun\"]) {\n        func(Module);\n      } else {\n        var old = Module[\"onRuntimeInitialized\"];\n        Module[\"onRuntimeInitialized\"] = function () {\n          if (old) old();\n          func(Module);\n        };\n      }\n      return Module;\n    };\n    function ExitStatus(status) {\n      this.name = \"ExitStatus\";\n      this.message = \"Program terminated with exit(\" + status + \")\";\n      this.status = status;\n    }\n    ExitStatus.prototype = new Error();\n    ExitStatus.prototype.constructor = ExitStatus;\n    dependenciesFulfilled = function runCaller() {\n      if (!Module[\"calledRun\"]) run();\n      if (!Module[\"calledRun\"]) dependenciesFulfilled = runCaller;\n    };\n    function run(args) {\n      args = args || Module[\"arguments\"];\n      if (runDependencies > 0) {\n        return;\n      }\n      writeStackCookie();\n      preRun();\n      if (runDependencies > 0) return;\n      if (Module[\"calledRun\"]) return;\n      function doRun() {\n        if (Module[\"calledRun\"]) return;\n        Module[\"calledRun\"] = true;\n        if (ABORT) return;\n        ensureInitRuntime();\n        preMain();\n        if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n        assert(!Module[\"_main\"], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\n        postRun();\n      }\n      if (Module[\"setStatus\"]) {\n        Module[\"setStatus\"](\"Running...\");\n        setTimeout(function () {\n          setTimeout(function () {\n            Module[\"setStatus\"](\"\");\n          }, 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n      checkStackCookie();\n    }\n    Module[\"run\"] = run;\n    var abortDecorators = [];\n    function abort(what) {\n      if (Module[\"onAbort\"]) {\n        Module[\"onAbort\"](what);\n      }\n      if (what !== undefined) {\n        out(what);\n        err(what);\n        what = JSON.stringify(what);\n      } else {\n        what = \"\";\n      }\n      ABORT = true;\n      EXITSTATUS = 1;\n      var extra = \"\";\n      var output = \"abort(\" + what + \") at \" + stackTrace() + extra;\n      if (abortDecorators) {\n        abortDecorators.forEach(function (decorator) {\n          output = decorator(output, what);\n        });\n      }\n      throw output;\n    }\n    Module[\"abort\"] = abort;\n    if (Module[\"preInit\"]) {\n      if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [Module[\"preInit\"]];\n      while (Module[\"preInit\"].length > 0) {\n        Module[\"preInit\"].pop()();\n      }\n    }\n    Module[\"noExitRuntime\"] = true;\n    run();\n    return Module;\n  };\n}();\nif (typeof exports === 'object' && typeof module === 'object') module.exports = Module;else if (typeof define === 'function' && define['amd']) define([], function () {\n  return Module;\n});else if (typeof exports === 'object') exports[\"Module\"] = Module;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}